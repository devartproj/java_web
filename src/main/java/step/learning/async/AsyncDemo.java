package step.learning.async;

import java.util.Locale;

public class AsyncDemo {
    private double sum ;
    private final Object sumLocker = new Object() ;   // об'єкт синхронізації
    private int activeThreadsCount ;  // кількість незавершених потоків
    private final Object atcLocker = new Object() ;
    public void run() {
        /*
        Задача: АПІ банку видає проценти інфляції за кожен місяць,
        для їх одержання необхідні окремі запити. Необхідно
        реалізувати їх (імітацію) в асинхронному режимі. Визначити
        річну інфляцію.
        Особливість - річна інфляція не є сумою місячних показників
           ( 100 + 10% ) + 10% = 121 =/= 120 = 100 + ( 10% + 10% )
        ? А чи можна переставляти показники ?
           ( 100 + 20% ) + 10% =?= ( 100 + 10% ) + 20%
        можна, але у розумінні "додавання" процентів
        Оскільки можна переставляти, алгоритм не залежить від порядку
        а значить немає потреби зберігати всі отримані дані, слід їх
        відразу враховувати.
         */
        int months = 12 ;
        Thread[] threads = new Thread[months];
        sum = 100 ;
        activeThreadsCount = months;
        for( int i = 0; i < months; i++ ) {
            threads[i] = new Thread( new MonthRate( i + 1 ) ) ;
            threads[i].start() ;
        }
        /*
        // Завдання - визначити який з потоків останній, вивести підсумок
        // Рішення 1) - очікування усіх потоків.
        try {
            for( int i = 0; i < 12; i++ ) {
                threads[i].join() ;
            }
        }
        catch (InterruptedException e) {
            System.err.println(e.getMessage());
        }
        System.out.println( "----------------\nTotal: " + sum ) ;
         */
    }
    class MonthRate   // Nested class - class inside class
            implements Runnable {
        int month ;
        public MonthRate( int month ) {
            this.month = month;
        }
        @Override
        public void run() {
            try {
                Thread.sleep(1000);   // імітація тривалого запиту
            } catch (InterruptedException ex) {
                System.err.println(ex.getMessage());
            }
            double percent = 10.0;  // вважаємо, що це надішло у відповідь
            double factor = (1.0 + percent / 100.0) ;  // "додавання" процентів
            double localSum ;  // локальні змінні не взаємодіють (у різних потоках)
            synchronized( sumLocker ) {  // синхроблок, аналог lock{} у C#
                localSum =  // зкопіювавши "свої" дані у локальну змінну можна "відпускати" глобальну
                    sum = sum * factor ;
                // розгорнуто: read(sum) calc(expr) save(sum)  printf(sum)
                // інший потік:          read(sum)  calc(expr) save(sum)   printf(sum)
            }
            System.out.printf(
                    Locale.US,
                    "Month: %02d, percent: %.1f, sum: %.2f %n",
                    this.month, percent, localSum
            );
            // Завдання - визначити який з потоків останній, вивести підсумок
            // Рішення 2) - потік визначає чи він є останнім.
            // 1) activeThreadsCount--;(2->1)       if(activeThreadsCount == 0)
            // 2)            activeThreadsCount--;(1->0)       if(activeThreadsCount == 0)

            boolean isLast ;
            synchronized (atcLocker) {
                activeThreadsCount--;
                isLast = activeThreadsCount == 0 ;
            }
            try {
                Thread.sleep(1);  // збільшення імовірності проблеми
            }
            catch (InterruptedException ex) {
                System.err.println(ex.getMessage());
            }
            if (isLast) {  // даний потік останній
                System.out.println("----------------\nTotal: " + sum);
            }
            /*
            Д.З. Засобами багатопоточності реалізувати задачу формування
            pandigital числа, яке складається з усіх цифр 0-9. Порядок
            цифр ролі не грає.
            Запустити 10 потоків, кожен з яких здійснює затримку на 1с
            після чого додає свою цифру до спільного
            "числа" (String) та виводить проміжний результат:
              додано 7, результат 1287
            Передбачити усі необхідні заходи синхронізації.
            У кінці виводиться підсумок один раз
             ---------
             Результат 1287034659
             */
        }
    }
    public void run1() {
        System.out.println("Async Demo");
        Thread thread1 = new Thread(
                new  // анонімний об'єкт
                        Runnable() {  // анонімна реалізація
                    @Override
                    public void run() {
                        System.out.println( "Thread 1 starts" ) ;
                        try {
                            Thread.sleep( 1000 ) ;
                        } catch (InterruptedException e) {
                            System.err.println( e.getMessage() );
                        }
                        System.out.println( "Thread 1 finishes" ) ;
                    }
                }
        );
        thread1.start();  // старт нового потоку
        // якщо між стартом та очікуванням немає ніяких інструкцій,
        // то це неоптимальне використання потоку і можна його
        // запускати синхронно, методом run()
        try {
            thread1.join();  // очікування - блокування даного потоку
            // (AsyncDemo) до завершення thread1
        } catch (InterruptedException e) {
            System.err.println( e.getMessage() );
        }
        System.out.println("Async Demo finishes");
    }
}
/*
Асинхронне програмування
Синхронне виконання коду - послідовне, один-за-одним виконання коду
    ----1---- =====2====== ~~3~~
Асинхронність - будь-яке відхилення від синхронного виконання
Наприклад, паралельність (одночасно виконуються декілька інструкцій)
    ----1----
     =====2======
     ~~~~3~~~~
Імітована паралельність (одночасно - тільки одна інструкція, але
                             завдання 1, 2, 3 виконуються паралельно)
  - - - - 1 - - - - ~ ~ 3 ~ ~
   = = = = = 2 = = = = = = = =

Способи реалізації асинхронності
 - багатозадачність: використання об'єктів рівня мови/платформи ("задач")
 - багатопоточність: використання об'єктів рівня ОС ("потоків")
 - багатопроцесність (мікросервісна архітектура)
 - мережні технології (grid-, network-)

 */
/*
Багатопоточність - використання об'єктів Thread, які "відображають"
системні ресурси-потоки.
Ресурс приймає покажчик на функцію, відповідно, в ООП - це посилання
на об'єкт. У рамках Java посилання на метод - не вживаються, підхід
схожий на функтори, - задіює функціональні інтерфейси.
Функціональний інтерфейс - тип, який містить лише один метод.
Для старту потоку необхідно створити об'єкт ф.і. Runnable та передати
його у конструктор Thread
У той же час, у Java є можливість inline реалізації інтерфейсів та
створення її об'єктів (анонімний об'єкт анонімного класу, що реалізує
заданий інтерфейс)
Створений об'єкт Thread не запускає активність, лише створює об'єкт.
Для запуску можна використати методи
 .run() - синхронний запуск (у даному потоці)
 .start() - асинхронний запуск (у новому потоці)
Особливості багатопоточності
 = нові потоки стартують з нормальним пріоритетом (як і основний потік),
    значить процес (програма) не зупиняється доки працюють інші потоки,
    навіть якщо завершується головний потік (main)
    "+" потік допрацює, навіть якщо зупиниться main (у т.ч. вікно)
        не вимагається очікування інших потоків (вони не зруйнуються
          закриттям вікна)
    "-" закриття вікна не завершить процес, вікна не буде, але
          процес буде продовжуватись
 */
